<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Digit Dataset Creator</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }
        .container {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 100%;
            box-shadow: 0 20px 60px rgba(0,0,0,0.3);
        }
        h1 {
            color: #667eea;
            text-align: center;
            margin-bottom: 10px;
            font-size: 28px;
        }
        .subtitle {
            text-align: center;
            color: #666;
            margin-bottom: 30px;
            font-size: 14px;
        }
        .digit-selector {
            text-align: center;
            margin-bottom: 20px;
        }
        .digit-selector label {
            font-weight: 600;
            color: #333;
            margin-right: 10px;
            font-size: 16px;
        }
        .digit-selector select {
            padding: 8px 15px;
            font-size: 16px;
            border: 2px solid #667eea;
            border-radius: 8px;
            cursor: pointer;
            background: white;
        }
        .btn {
            width: 100%;
            padding: 15px;
            margin: 10px 0;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        .btn-primary {
            background: #667eea;
            color: white;
        }
        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102,126,234,0.4);
        }
        .btn-secondary {
            background: #f0f0f0;
            color: #333;
        }
        .btn-secondary:hover {
            background: #e0e0e0;
        }
        .btn-success {
            background: #10b981;
            color: white;
        }
        .btn-success:hover {
            background: #059669;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(16,185,129,0.4);
        }
        .drawing-area {
            display: flex;
            flex-direction: column;
            gap: 20px;
            margin: 20px 0;
        }
        @media (min-width: 768px) {
            .drawing-area {
                flex-direction: row;
                align-items: stretch;
                justify-content: center;
            }
        }
        .right-column {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }
        @media (min-width: 768px) {
            .right-column {
                min-width: 200px;
            }
        }
        .canvas-container {
            text-align: center;
            flex-shrink: 0;
        }
        #drawCanvas {
            border: 3px solid #667eea;
            border-radius: 10px;
            background: white;
            cursor: crosshair;
            touch-action: none;
        }
        .preview-container {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 30px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 10px;
            min-height: 200px;
            flex-shrink: 0;
        }
        @media (min-width: 768px) {
            .preview-container {
                flex-direction: column;
            }
        }
        .preview-box {
            text-align: center;
        }
        .preview-box h3 {
            color: #666;
            font-size: 12px;
            margin-bottom: 10px;
            text-transform: uppercase;
            font-weight: 600;
        }
        #canvas {
            width: 112px;
            height: 112px;
            image-rendering: pixelated;
            image-rendering: crisp-edges;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            background: #f5f5f5;
        }
        .placeholder-text {
            color: #999;
            font-size: 11px;
            margin-top: 8px;
            font-style: italic;
        }
        .info {
            background: #e3f2fd;
            border-left: 4px solid #2196f3;
            padding: 12px;
            margin: 15px 0;
            border-radius: 5px;
            font-size: 13px;
            color: #1976d2;
        }
        .success-message {
            background: #d1fae5;
            border: 2px solid #10b981;
            padding: 12px;
            border-radius: 8px;
            font-size: 13px;
            color: #065f46;
            text-align: center;
            font-weight: 600;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .success-message.show {
            opacity: 1;
        }
        .success-message:not(.show) {
            visibility: hidden;
            position: absolute;
        }
        .image-counter {
            text-align: center;
            opacity: 1;
            transition: opacity 0.3s;
        }
        .image-counter.hide {
            opacity: 0;
            visibility: hidden;
            position: absolute;
        }
        .image-counter .count {
            font-size: 48px;
            font-weight: bold;
            color: #667eea;
            line-height: 1;
            margin-bottom: 8px;
        }
        .image-counter .label {
            font-size: 12px;
            color: #666;
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: 0.5px;
        }
        .mode-toggle {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }
        .mode-btn {
            flex: 1;
            padding: 12px;
            border: 2px solid #667eea;
            border-radius: 10px;
            background: white;
            color: #667eea;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }
        .mode-btn.active {
            background: #667eea;
            color: white;
        }
        .mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 3px 10px rgba(102,126,234,0.3);
        }
        .random-digit-display {
            text-align: center;
            margin-bottom: 20px;
            display: none;
        }
        .random-digit-display.show {
            display: block;
        }
        .random-digit-display .label {
            font-size: 14px;
            color: #666;
            margin-bottom: 5px;
        }
        .random-digit-display .digit {
            font-size: 64px;
            font-weight: bold;
            color: #667eea;
            text-shadow: 2px 2px 4px rgba(102,126,234,0.3);
        }
        .status-container {
            background: #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            flex-grow: 1;
            min-height: 80px;
        }
        .auto-save-countdown {
            text-align: center;
            color: #667eea;
            font-weight: 600;
            font-size: 13px;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .auto-save-countdown.show {
            opacity: 1;
        }
        .auto-save-countdown:not(.show) {
            visibility: hidden;
            position: absolute;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üìä Digit Dataset Creator</h1>
        <div class="subtitle">Draw digits to build your training dataset</div>

        <div class="info" id="infoMessage">
            ‚úèÔ∏è Draw a digit - it will auto-save after 1 second! Random mode cycles through all digits 0-9 for balanced dataset.
        </div>

        <!-- Mode Toggle -->
        <div class="mode-toggle">
            <button class="mode-btn active" onclick="setMode('manual')">‚úã Manual Select</button>
            <button class="mode-btn" onclick="setMode('random')">üé≤ Random Mode</button>
        </div>

        <!-- Random Digit Display -->
        <div class="random-digit-display" id="randomDigitDisplay">
            <div class="label">Draw this digit:</div>
            <div class="digit" id="randomDigit">7</div>
        </div>

        <!-- Digit Selection -->
        <div class="digit-selector" id="digitSelector">
            <label for="digitSelect">I'm drawing digit:</label>
            <select id="digitSelect">
                <option value="0">0</option>
                <option value="1">1</option>
                <option value="2">2</option>
                <option value="3">3</option>
                <option value="4">4</option>
                <option value="5">5</option>
                <option value="6">6</option>
                <option value="7">7</option>
                <option value="8">8</option>
                <option value="9">9</option>
            </select>
        </div>

        <!-- Drawing Area (Canvas + Preview side-by-side on desktop) -->
        <div class="drawing-area">
            <div class="canvas-container">
                <canvas id="drawCanvas" width="280" height="280"></canvas>
            </div>

            <div class="right-column">
                <!-- Preview Container (always visible) -->
                <div class="preview-container" id="previewContainer">
                    <div class="preview-box">
                        <h3>28√ó28 Processed</h3>
                        <canvas id="canvas" width="28" height="28"></canvas>
                        <div class="placeholder-text" id="placeholderText">Draw to see preview</div>
                    </div>
                </div>

                <!-- Status Container (fills remaining space) -->
                <div class="status-container">
                    <div class="image-counter" id="imageCounter">
                        <div class="count" id="imageCount">0</div>
                        <div class="label">Images Saved</div>
                    </div>
                    <div class="auto-save-countdown" id="autoSaveCountdown">üíæ Auto-saving in 1 second...</div>
                    <div class="success-message" id="successMessage">‚úì Saved!</div>
                </div>
            </div>
        </div>

        <button class="btn btn-secondary" onclick="clearCanvas()" style="width: 100%;">üóëÔ∏è Clear & Start Over</button>
    </div>

    <script>
        // Drawing canvas setup
        const drawCanvas = document.getElementById('drawCanvas');
        const drawCtx = drawCanvas.getContext('2d');
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let processedImageData = null;

        // Auto-processing and auto-save timers
        let autoProcessTimer = null;
        let autoSaveTimer = null;
        let clearCanvasTimer = null; // Track the clear canvas timeout from previous save
        let currentMode = 'manual';
        let currentRandomDigit = null;

        // Shuffled queue for truly balanced random mode
        let digitQueue = [];

        // Initialize drawing canvas
        drawCtx.fillStyle = 'white';
        drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);
        drawCtx.strokeStyle = '#000000';
        drawCtx.lineWidth = 20;
        drawCtx.lineCap = 'round';
        drawCtx.lineJoin = 'round';

        // Initialize preview canvas with placeholder
        function drawPlaceholder() {
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(0, 0, 28, 28);
            // Draw a subtle question mark or grid pattern
            ctx.fillStyle = '#d0d0d0';
            ctx.fillRect(13, 13, 2, 2); // Center dot as placeholder
        }
        drawPlaceholder();

        // Fetch and update image count
        async function updateImageCount() {
            try {
                const response = await fetch('/image-count');
                const data = await response.json();
                if (data.success) {
                    document.getElementById('imageCount').textContent = data.total;
                }
            } catch (error) {
                console.error('Failed to fetch image count:', error);
            }
        }

        // Update count on page load
        updateImageCount();

        // Mode switching
        function setMode(mode) {
            currentMode = mode;

            // Update button states
            document.querySelectorAll('.mode-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            event.target.classList.add('active');

            if (mode === 'random') {
                document.getElementById('digitSelector').style.display = 'none';
                document.getElementById('randomDigitDisplay').classList.add('show');
                pickRandomDigit();
            } else {
                document.getElementById('digitSelector').style.display = 'block';
                document.getElementById('randomDigitDisplay').classList.remove('show');
            }

            clearCanvas();
        }

        // Shuffle array using Fisher-Yates algorithm
        function shuffleArray(array) {
            const arr = [...array];
            for (let i = arr.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [arr[i], arr[j]] = [arr[j], arr[i]];
            }
            return arr;
        }

        // Refill the queue with shuffled digits 0-9
        function refillDigitQueue() {
            digitQueue = shuffleArray([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);
        }

        function pickRandomDigit() {
            // If queue is empty, refill it with shuffled digits
            if (digitQueue.length === 0) {
                refillDigitQueue();
            }
            // Pop the next digit from the queue
            currentRandomDigit = digitQueue.pop();
            document.getElementById('randomDigit').textContent = currentRandomDigit;
        }

        function getCurrentDigit() {
            if (currentMode === 'random') {
                return currentRandomDigit;
            } else {
                return parseInt(document.getElementById('digitSelect').value);
            }
        }

        // Drawing functions (copied from .ino file)
        function startDrawing(e) {
            isDrawing = true;

            // Cancel ALL pending timers if user starts drawing again
            if (autoProcessTimer) {
                clearTimeout(autoProcessTimer);
                autoProcessTimer = null;
            }
            if (autoSaveTimer) {
                clearTimeout(autoSaveTimer);
                autoSaveTimer = null;
                document.getElementById('autoSaveCountdown').classList.remove('show');
            }
            if (clearCanvasTimer) {
                clearTimeout(clearCanvasTimer);
                clearCanvasTimer = null;
            }
            // Hide success message if still showing
            document.getElementById('successMessage').classList.remove('show');

            const rect = drawCanvas.getBoundingClientRect();
            const scaleX = drawCanvas.width / rect.width;
            const scaleY = drawCanvas.height / rect.height;

            if (e.type.includes('mouse')) {
                lastX = (e.clientX - rect.left) * scaleX;
                lastY = (e.clientY - rect.top) * scaleY;
            } else {
                lastX = (e.touches[0].clientX - rect.left) * scaleX;
                lastY = (e.touches[0].clientY - rect.top) * scaleY;
            }
        }

        function draw(e) {
            if (!isDrawing) return;
            e.preventDefault();

            const rect = drawCanvas.getBoundingClientRect();
            const scaleX = drawCanvas.width / rect.width;
            const scaleY = drawCanvas.height / rect.height;

            let currentX, currentY;
            if (e.type.includes('mouse')) {
                currentX = (e.clientX - rect.left) * scaleX;
                currentY = (e.clientY - rect.top) * scaleY;
            } else {
                currentX = (e.touches[0].clientX - rect.left) * scaleX;
                currentY = (e.touches[0].clientY - rect.top) * scaleY;
            }

            drawCtx.beginPath();
            drawCtx.moveTo(lastX, lastY);
            drawCtx.lineTo(currentX, currentY);
            drawCtx.stroke();

            lastX = currentX;
            lastY = currentY;
        }

        function stopDrawing() {
            isDrawing = false;

            // Start auto-processing timer (1 second after user stops drawing)
            if (autoProcessTimer) clearTimeout(autoProcessTimer);
            autoProcessTimer = setTimeout(() => {
                processDrawing();
            }, 1000);
        }

        function clearCanvas() {
            // Clear all timers
            if (autoProcessTimer) clearTimeout(autoProcessTimer);
            if (autoSaveTimer) clearTimeout(autoSaveTimer);
            if (clearCanvasTimer) clearTimeout(clearCanvasTimer);
            autoProcessTimer = null;
            autoSaveTimer = null;
            clearCanvasTimer = null;

            drawCtx.fillStyle = 'white';
            drawCtx.fillRect(0, 0, drawCanvas.width, drawCanvas.height);

            // Reset preview to placeholder
            drawPlaceholder();
            document.getElementById('placeholderText').style.display = 'block';

            // Hide messages, show counter
            document.getElementById('autoSaveCountdown').classList.remove('show');
            document.getElementById('successMessage').classList.remove('show');
            document.getElementById('imageCounter').classList.remove('hide');

            processedImageData = null;
        }

        // Mouse events
        drawCanvas.addEventListener('mousedown', startDrawing);
        drawCanvas.addEventListener('mousemove', draw);
        drawCanvas.addEventListener('mouseup', stopDrawing);
        drawCanvas.addEventListener('mouseout', stopDrawing);

        // Touch events for mobile
        drawCanvas.addEventListener('touchstart', startDrawing);
        drawCanvas.addEventListener('touchmove', draw);
        drawCanvas.addEventListener('touchend', stopDrawing);

        // Process drawing function (copied and adapted from .ino file)
        function processDrawing() {
            document.getElementById('successMessage').classList.remove('show');

            // Create temporary canvas for original image
            const originalCanvas = document.createElement('canvas');
            const originalCtx = originalCanvas.getContext('2d');
            originalCanvas.width = drawCanvas.width;
            originalCanvas.height = drawCanvas.height;
            originalCtx.drawImage(drawCanvas, 0, 0);

            // Step 1: Draw original to temporary canvas for processing
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = originalCanvas.width;
            tempCanvas.height = originalCanvas.height;
            tempCtx.drawImage(originalCanvas, 0, 0);

            // Step 2: Convert to grayscale
            let imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            let data = imageData.data;
            for (let i = 0; i < data.length; i += 4) {
                const gray = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                data[i] = data[i + 1] = data[i + 2] = gray;
            }
            tempCtx.putImageData(imageData, 0, 0);

            // Step 3: Detect if we need to invert (before resizing for better detection)
            let totalBrightness = 0;
            for (let i = 0; i < data.length; i += 4) {
                totalBrightness += data[i];
            }
            const avgBrightness = totalBrightness / (data.length / 4);
            const needsInversion = avgBrightness > 127;

            // Step 4: Invert if needed
            if (needsInversion) {
                for (let i = 0; i < data.length; i += 4) {
                    data[i] = data[i + 1] = data[i + 2] = 255 - data[i];
                }
                tempCtx.putImageData(imageData, 0, 0);
            }

            // Step 5: Find bounding box of the digit (crop to content)
            imageData = tempCtx.getImageData(0, 0, tempCanvas.width, tempCanvas.height);
            data = imageData.data;

            let minX = tempCanvas.width, minY = tempCanvas.height;
            let maxX = 0, maxY = 0;
            const threshold = 20;

            for (let y = 0; y < tempCanvas.height; y++) {
                for (let x = 0; x < tempCanvas.width; x++) {
                    const idx = (y * tempCanvas.width + x) * 4;
                    if (data[idx] > threshold) {
                        if (x < minX) minX = x;
                        if (x > maxX) maxX = x;
                        if (y < minY) minY = y;
                        if (y > maxY) maxY = y;
                    }
                }
            }

            // Add minimal padding around the digit for tight crop
            const digitWidth = maxX - minX;
            const digitHeight = maxY - minY;
            const padding = Math.max(digitWidth, digitHeight) * 0;

            minX = Math.max(0, minX - padding);
            minY = Math.max(0, minY - padding);
            maxX = Math.min(tempCanvas.width, maxX + padding);
            maxY = Math.min(tempCanvas.height, maxY + padding);

            const cropWidth = maxX - minX;
            const cropHeight = maxY - minY;

            // Check if we found any content
            if (cropWidth <= 0 || cropHeight <= 0 || !isFinite(cropWidth) || !isFinite(cropHeight)) {
                // Silently skip processing if no content detected
                return;
            }

            // Step 6: Crop to bounding box
            const croppedCanvas = document.createElement('canvas');
            const croppedCtx = croppedCanvas.getContext('2d');
            croppedCanvas.width = cropWidth;
            croppedCanvas.height = cropHeight;
            croppedCtx.drawImage(tempCanvas, minX, minY, cropWidth, cropHeight, 0, 0, cropWidth, cropHeight);

            // Step 7: Resize to fit within 20x20 (MNIST format)
            const size20Canvas = document.createElement('canvas');
            const size20Ctx = size20Canvas.getContext('2d');
            const maxDim = Math.max(cropWidth, cropHeight);
            const scale = 20 / maxDim;
            const scaledWidth = cropWidth * scale;
            const scaledHeight = cropHeight * scale;
            size20Canvas.width = scaledWidth;
            size20Canvas.height = scaledHeight;
            size20Ctx.drawImage(croppedCanvas, 0, 0, scaledWidth, scaledHeight);

            // Step 8: Center in 28x28 canvas (like MNIST does)
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, 28, 28);
            const offsetX = (28 - scaledWidth) / 2;
            const offsetY = (28 - scaledHeight) / 2;
            ctx.drawImage(size20Canvas, offsetX, offsetY);

            // Hide placeholder text
            document.getElementById('placeholderText').style.display = 'none';

            // Store processed image data
            processedImageData = canvas.toDataURL('image/png');

            // Hide counter, show countdown
            document.getElementById('imageCounter').classList.add('hide');

            // Start auto-save timer (1 second after processing)
            const countdown = document.getElementById('autoSaveCountdown');
            countdown.textContent = 'üíæ Auto-saving in 1 second...';
            countdown.classList.add('show');

            if (autoSaveTimer) clearTimeout(autoSaveTimer);
            autoSaveTimer = setTimeout(() => {
                countdown.classList.remove('show');
                saveToDataset();
            }, 1000);
        }

        async function saveToDataset() {
            if (!processedImageData) {
                return; // Silently skip if no processed image
            }

            const digit = getCurrentDigit();

            try {
                const response = await fetch('/save-image', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        digit: digit,
                        imageData: processedImageData
                    })
                });

                const data = await response.json();

                if (data.success) {
                    // Update the image count
                    await updateImageCount();

                    // Hide countdown, show success message
                    document.getElementById('autoSaveCountdown').classList.remove('show');
                    const msg = document.getElementById('successMessage');
                    msg.textContent = `‚úì Saved digit ${digit} to dataset!`;
                    msg.classList.add('show');

                    // Clear canvas and pick new random digit if in random mode
                    clearCanvasTimer = setTimeout(() => {
                        msg.classList.remove('show');
                        document.getElementById('imageCounter').classList.remove('hide');
                        clearCanvas();
                        if (currentMode === 'random') {
                            pickRandomDigit();
                        }
                    }, 1000);
                } else {
                    alert('Error: ' + data.error);
                }
            } catch (error) {
                alert('Failed to save: ' + error.message);
            }
        }
    </script>
</body>
</html>
